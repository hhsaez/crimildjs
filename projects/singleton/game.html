<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Singleton: The Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <link rel="stylesheet" type="text/css" href="../../css/example.css">
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/bootstrap-responsive.min.css" rel="stylesheet">

    <script type="text/javascript" src="../../js/jquery-1.8.2.min.js"></script>
    <script type="text/javascript" src="../../js/bootstrap.min.js"></script>
    <script data-main="../../src/crimild" src="../../lib/require.js"></script>
    <style type="text/css">
        body {
            color: white;
            padding: 0;
        }

        .menu {
            position: absolute;
            text-align: center;
        }

        #mainMenu {
            width:390px;
            top: 40px;
            left: 122px;
        }

        .help {
            text-align: left;
            margin-top: 60px;
        }

        #gameOver {
            top: 125px;
            left: 215px;
        }

        .btn-game-over {
            margin-top: 30px;
        }

        #levelCompleted {
            top: 125px;
            left: 130px;
        }

        .btn-level-completed {
            margin-top: 30px;
        }
    </style>
    <script id="dissolve-vs" type="x-shader/x-fragment">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uMMatrix;
        uniform mat4 uVMatrix;
        uniform mat4 uPMatrix;
        uniform mat3 uNMatrix;

        varying vec2 vTextureCoord;
        varying vec4 vVertexPosition;

        void main(void) {
            vVertexPosition = uMMatrix * vec4(aVertexPosition, 1.0);
            gl_Position = uPMatrix * uVMatrix * vVertexPosition;
            vTextureCoord = aTextureCoord;
        }
    </script>
    <script id="dissolve-fs" type="x-shader/x-fragment">
        precision mediump float;

        struct Material {
            vec3 Ambient;
            vec3 Diffuse;
            vec3 Specular;
            float Shininess;
        };

        uniform bool uUseTextures;
        uniform sampler2D uSampler;
        uniform Material uMaterial;
        uniform float uTime;

        varying vec2 vTextureCoord;
        varying vec4 vVertexPosition;

        void main(void) {
            vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
            color *= vec4(uMaterial.Diffuse, 1.0);

            float t = uTime + (vVertexPosition.x / (vVertexPosition.z + 0.1));
            clamp(t, 0.0, 1.0);

            vec4 dissolveColor = texture2D(uSampler, vec2(vTextureCoord.s + 0.25, vTextureCoord.t));

            if (dissolveColor.r < uTime) {
                discard;
            }

            gl_FragColor = color;
        }
    </script>
    <script type="text/javascript">
        var playerActor = null;
        var worldMap = [];
        var waypoints = [];

        function querystring(key) {
            var re=new RegExp('(?:\\?|&)'+key+'=(.*?)(?=&|$)','gi');
            var r=[], m;
            while ((m=re.exec(document.location.search)) != null) r.push(m[1]);
            return r;
        }

        var level = (function() {
            var keys = querystring("level");
            if (keys && keys.length > 0) {
                return parseInt(keys[0]);
            }

            return 0;
        })();

        var baseCorrumption = (function() {
            var keys = querystring("corruption");
            if (keys && keys.length > 0) {
                return parseFloat(keys[0]);
            }

            return 0.5;
        })();

        var settings = {
            MAP_SIZE_X: 19,
            MAP_SIZE_Z: 21,
            MAP_SIZE_DIAGONAL: 0,
            PROGRAM_COUNT: 30,
            ANTIVIRUS_COUNT: 15,
            CORRUPTION_REQUIRED: baseCorrumption,
            KEY_WALK_FORWARD: "W".charCodeAt(0),
            KEY_WALK_FORWARD_ALT: 38,
            KEY_WALK_BACKWARD: "S".charCodeAt(0),
            KEY_WALK_BACKWARD_ALT: 40,
            KEY_TURN_RIGHT: "D".charCodeAt(0),
            KEY_TURN_RIGHT_ALT: 39,
            KEY_TURN_LEFT: "A".charCodeAt(0),
            KEY_TURN_LEFT_ALT: 37,
            KEY_STRAFE_LEFT: 'Z'.charCodeAt(0),
            KEY_STRAFE_RIGHT: 'X'.charCodeAt(0),
            KEY_ATTACK: 32,
        };

        settings.MAP_SIZE_DIAGONAL = Math.sqrt(settings.MAP_SIZE_X * settings.MAP_SIZE_X + settings.MAP_SIZE_Z * settings.MAP_SIZE_Z);

        var tiles = {
            WALL: 0,
            FLOOR: 1,
            PLAYER: 10,
            PROGRAM: 21,
            SCANNER: 22,
            ANTIVIRUS: 23,
            KERNEL: 30,
            UNKNOWN: 999,
        };

        var actorType = {
            PLAYER: 0,
            PROGRAM: 1,
            UNKNOWN: 999,
        };

        var actorOrientation = {
            NORTH: 0,
            EAST: 1,
            SOUTH: 2,
            WEST: 3,
        };

        var actorStatus = {
            IDLE: 0,
            MOVING: 1,
            ZOMBIE: 900,  
            DYING: 950,
            DEAD: 999,          
        };

        var playerRiskLevel = {
            SAFE: 0,
            WARNING: 1,
            FOUND: 2,
        };

        function loadAudio(src, autoplay, loop) {
            var audioElement = document.createElement('audio');
            audioElement.setAttribute('src', src);
            audioElement.loop = loop;
            audioElement.addEventListener("loadeddata", function() { 
                if (autoplay) {
                    audioElement.play(); 
                }
            });
            audioElement.load();
            return audioElement;
        };

        function createActor(type, waypoint) {
            var actor = {
                position: [0, 0],
                speed: 0.05,
                orientation: actorOrientation.NORTH,
                status: actorStatus.IDLE,
                waypoint: null,
                type: type,

                setWaypoint: function(wp) {
                    if (this.waypoint) {
                        this.waypoint.setActor(null);
                    }

                    this.waypoint = wp;

                    if (this.waypoint) {
                        this.waypoint.setActor(this);
                        this.position = this.waypoint.position;
                    }
                },

                kill: function(killer) {
                    if (this.status != actorStatus.DEAD && this.status != actorStatus.DYING) {
                        if (this.status == actorStatus.MOVING) {
                            this.status = actorStatus.ZOMBIE;
                        }
                        else {
                            this.status = actorStatus.DYING;
                        }
                    }

                    this.killer = killer;
                }
            };

            if (type == actorType.PLAYER) {
                playerActor = actor;
            };

            actor.setWaypoint(waypoint);
            return actor;
        }

        function createWaypoint(x, y) {
            return {
                position: [x, y],
                actor: null,
                northNeighbor: null,
                eastNeighbor: null,
                southNeighbor: null,
                westNeighbor: null,

                setActor: function(actor) {
                    this.actor = actor;
                },

                isAvailable: function() {
                    return this.actor == null;
                },
            }
        }

        function generateLevel(worldTxt, sizeX, sizeY) {
            var lines = worldTxt.split("\n");
            var waypointMap = [];

            for (var z = 0; z < sizeY; z++) {
                for (var x = 0; x < sizeX; x++) {
                    waypointMap.push(null);
                }
            }

            for (var z = 0; z < sizeY; z++) {
                var vals = lines[z];
                for (var x = 0; x < sizeX; x++) {
                    var tile = vals[x];
                    if (tile == '#') {
                        worldMap.push(tiles.WALL);
                    }
                    else if (tile == ' ') {
                        worldMap.push(tiles.FLOOR);
                        var wp = createWaypoint(x, z)
                        waypointMap[z * sizeX + x] = wp;
                        waypoints.push(wp);
                    }
                }
            }

            for (var z = 0; z < sizeY; z++) {
                for (var x = 0; x < sizeX; x++) {
                    var wp = waypointMap[z * sizeX + x];
                    if (wp) {
                        if (x > 0) wp.westNeighbor = waypointMap[z * sizeX + x - 1];
                        if (x < sizeX - 1) wp.eastNeighbor = waypointMap[z * sizeX + x + 1];
                        if (z > 0) wp.northNeighbor = waypointMap[(z - 1) * sizeX + x];
                        if (z < sizeY - 1) wp.southNeighbor = waypointMap[(z + 1) * sizeX + x];
                    }
                }
            }
        }

        function getRandomWaypoint() {
            return waypoints[Math.floor(Math.random() * waypoints.length)];
        }

        function getAvailableWaypoint() {
            var wp = null;
            do {
                wp = getRandomWaypoint(waypoints);    
            } while (!wp.isAvailable());
            return wp;
        }

        function initCrimild(canvasId) {
            require(["crimild", "text!../projects/singleton/dissolve.vert"], function(crimild, dissolve_vs) {
                var showMainMenu = function() {
                    $('#loading').hide();
                    $('#mainMenu').show();
                    $('#gameOver').hide();
                    $('levelCompleted').hide();

                    $('a.start-game-easy').click(function() {
                        settings.CORRUPTION_REQUIRED = 0.25;
                        startGame();
                    });

                    $('a.start-game-normal').click(function() {
                        settings.CORRUPTION_REQUIRED = 0.5;
                        startGame();
                    });

                    $('a.start-game-hard').click(function() {
                        settings.CORRUPTION_REQUIRED = 0.75;
                        startGame();
                    });

                    $('a.start-game-hardcore').click(function() {
                        settings.CORRUPTION_REQUIRED = 0.95;
                        startGame();
                    });
                }

                var showGameOver = function() {
                    $('#loading').hide();
                    $('#mainMenu').hide();
                    $('#gameOver').show();
                    $('levelCompleted').hide();
                }

                var showLevelCompleted = function() {
                    $('#loading').hide();
                    $('#mainMenu').hide();
                    $('#gameOver').hide();
                    $('#levelCompleted').show();

                    $('a.btn-next-level').click(function() {
                        window.location = "game.html?level=" + (level + 1) + "&corruption=" + settings.CORRUPTION_REQUIRED;
                    });
                }

                var assetManager = crimild.utils.assetManager();
                assetManager.queueImage("assets/texture.png");
                assetManager.queueFile("assets/world.txt");
                assetManager.loadAll(function() {
                    if (level > 0) {
                        startGame();
                    }
                    else {
                        showMainMenu();
                    }

                    $('#level').html(level + 1);
                });

                var startGame = function() {
                    $('#loading').hide();
                    $('#mainMenu').hide();
                    $('#gameOver').hide();
                    $('levelCompleted').hide();
                    $('#game').show();

                    var canvas = document.getElementById(canvasId);
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    var mapSizeX = settings.MAP_SIZE_X;
                    var mapSizeY = settings.MAP_SIZE_Z;
                    generateLevel(assetManager.getFile("assets/world.txt"), mapSizeX, mapSizeY);

                    var megaTexture = crimild.rendering.texture({
                        image: assetManager.getImage("assets/texture.png")
                    })

                    var corruptionLevel = 0.0;
                    var corruptionRequired = Math.min(1.0, settings.CORRUPTION_REQUIRED + (level * 0.01));
                    var riskLevel = playerRiskLevel.SAFE;
                    var levelCompleted = false;

                    var createActorBehavior = function(type, waypoint) {
                        var cmp = crimild.core.nodeComponent({
                            name: "behavior",
                        });

                        cmp.actor = createActor(type, waypoint);

                        cmp.onAttach = function() {
                            cmp.node.local.translate = [cmp.actor.waypoint.position[0], 0.0, cmp.actor.waypoint.position[1]]
                        };

                        cmp.updateTransform = function(endTransformation) {
                            cmp.node.attachComponent(crimild.components.lerpTransformComponent({
                                name: "interpolateBehavior",
                                start: cmp.node.local,
                                end: endTransformation,
                                speed: cmp.actor.speed,
                                callback: function() {
                                    if (cmp.actor.status == actorStatus.MOVING) {
                                        cmp.actor.status = actorStatus.IDLE;
                                    }
                                    else if (cmp.actor.status == actorStatus.ZOMBIE) {
                                        cmp.actor.status = actorStatus.DYING;
                                    }
                                }
                            }));
                            cmp.actor.status = actorStatus.MOVING;
                        };

                        cmp.getWaypointAtFront = function() {
                            if (cmp.actor.orientation === actorOrientation.NORTH) {
                                return cmp.actor.waypoint.northNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.SOUTH) {
                                return cmp.actor.waypoint.southNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.EAST) {
                                return cmp.actor.waypoint.eastNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.WEST) {
                                return cmp.actor.waypoint.westNeighbor;
                            }

                            return null;
                        };

                        cmp.moveForward = function() {
                            var targetWaypoint = cmp.getWaypointAtFront();
                            var endTransformation = crimild.math.transformation();
                            endTransformation.set(cmp.node.local);

                            if (targetWaypoint && targetWaypoint.isAvailable()) {
                                endTransformation.translate = [targetWaypoint.position[0], 0, targetWaypoint.position[1]];
                                cmp.actor.setWaypoint(targetWaypoint);
                                cmp.updateTransform(endTransformation);
                                return true;
                            }

                            return false;
                        };

                        cmp.moveBackward = function() {
                            var targetWaypoint = null;
                            var endTransformation = crimild.math.transformation();
                            endTransformation.set(cmp.node.local);

                            if (cmp.actor.orientation === actorOrientation.NORTH) {
                                targetWaypoint = cmp.actor.waypoint.southNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.SOUTH) {
                                targetWaypoint = cmp.actor.waypoint.northNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.EAST) {
                                targetWaypoint = cmp.actor.waypoint.westNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.WEST) {
                                targetWaypoint = cmp.actor.waypoint.eastNeighbor;
                            }

                            if (targetWaypoint && targetWaypoint.isAvailable()) {
                                endTransformation.translate = [targetWaypoint.position[0], 0, targetWaypoint.position[1]];
                                cmp.actor.setWaypoint(targetWaypoint);
                                cmp.updateTransform(endTransformation);
                                return true;
                            }

                            return false;
                        };

                        cmp.moveLeft = function() {
                            var targetWaypoint = null;
                            var endTransformation = crimild.math.transformation();
                            endTransformation.set(cmp.node.local);

                            if (cmp.actor.orientation === actorOrientation.NORTH) {
                                targetWaypoint = cmp.actor.waypoint.westNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.SOUTH) {
                                targetWaypoint = cmp.actor.waypoint.eastNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.EAST) {
                                targetWaypoint = cmp.actor.waypoint.northNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.WEST) {
                                targetWaypoint = cmp.actor.waypoint.southNeighbor;
                            }

                            if (targetWaypoint && targetWaypoint.isAvailable()) {
                                endTransformation.translate = [targetWaypoint.position[0], 0, targetWaypoint.position[1]];
                                cmp.actor.setWaypoint(targetWaypoint);
                                cmp.updateTransform(endTransformation);
                                return true;
                            }

                            return false;
                        };

                        cmp.moveRight = function() {
                            var targetWaypoint = null;
                            var endTransformation = crimild.math.transformation();
                            endTransformation.set(cmp.node.local);

                            if (cmp.actor.orientation === actorOrientation.NORTH) {
                                targetWaypoint = cmp.actor.waypoint.eastNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.SOUTH) {
                                targetWaypoint = cmp.actor.waypoint.westNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.EAST) {
                                targetWaypoint = cmp.actor.waypoint.southNeighbor;
                            }
                            else if (cmp.actor.orientation === actorOrientation.WEST) {
                                targetWaypoint = cmp.actor.waypoint.northNeighbor;
                            }

                            if (targetWaypoint && targetWaypoint.isAvailable()) {
                                endTransformation.translate = [targetWaypoint.position[0], 0, targetWaypoint.position[1]];
                                cmp.actor.setWaypoint(targetWaypoint);
                                cmp.updateTransform(endTransformation);
                                return true;
                            }

                            return false;
                        };

                        cmp.turnLeft = function() {
                            var endTransformation = crimild.math.transformation();
                            endTransformation.set(cmp.node.local);

                            var qTemp = quat4.create();
                            quat4.fromAngleAxis(Math.PI / 2, [0, 1, 0], qTemp);
                            quat4.multiply(cmp.node.local.rotate, qTemp, endTransformation.rotate);
                            cmp.actor.orientation = (cmp.actor.orientation + 3) % 4;
                            cmp.updateTransform(endTransformation);
                        };

                        cmp.turnRight = function() {
                            var endTransformation = crimild.math.transformation();
                            endTransformation.set(cmp.node.local);

                            var qTemp = quat4.create();
                            quat4.fromAngleAxis(-Math.PI / 2, [0, 1, 0], qTemp);
                            quat4.multiply(cmp.node.local.rotate, qTemp, endTransformation.rotate);
                            cmp.actor.orientation = (cmp.actor.orientation + 1) % 4;
                            cmp.updateTransform(endTransformation);
                        };

                        cmp.update = function() {
                            cmp.node.perform(crimild.core.worldStateUpdate());
                        };

                        return cmp;
                    };

                    var createProgram = function() {
                        return crimild.core.groupNode({
                            nodes: [
                                crimild.core.geometryNode({
                                    primitives: [
                                        crimild.primitives.cubePrimitive({
                                            scale: [0.15, 0.15, 0.15],
                                            textureOffset: [0.0, 0.5],
                                            textureScale: [0.25, 0.25],
                                        }),
                                        crimild.core.primitive({
                                            type: crimild.core.primitive.types.TRIANGLES,
                                            vertexBuffer: crimild.core.vertexBufferObject({
                                                vertexFormat: crimild.core.vertexFormat({
                                                    positions: 3,
                                                    textureCoords: 2,
                                                }),
                                                data: new Float32Array([
                                                    -0.15, -0.35, -0.15, 0.51, 0.26, 
                                                    -0.15, -0.35, 0.15, 0.51, 0.49, 
                                                    0.15, -0.35, 0.15, 0.74, 0.49, 
                                                    0.15, -0.35, -0.15, 0.74, 0.26, 
                                                ]),
                                                vertexCount: 4,
                                            }),
                                            indexBuffer: crimild.core.indexBufferObject({
                                                data: new Uint16Array([0, 1, 2, 0, 2, 3]),
                                                indexCount: 6
                                            })
                                        }),
                                    ],
                                    components: [
                                        crimild.rendering.renderComponent({
                                            effects: [
                                                crimild.rendering.effect({
                                                    shaderProgram: crimild.rendering.shaderProgram({
                                                        vertexShader: crimild.rendering.shader({
                                                            //scriptId: "dissolve-vs"
                                                            content: dissolve_vs
                                                        }),
                                                        fragmentShader: crimild.rendering.shader({
                                                            scriptId: "dissolve-fs"
                                                        })
                                                    }),
                                                    textures: [
                                                        megaTexture,
                                                    ],
                                                    alphaState: crimild.rendering.alphaState({ enabled: true }),
                                                }),
                                            ],
                                        }),
                                    ],
                                    local: crimild.math.transformation({
                                        translate: [0, -0.1, 0],
                                    })
                                }),
                            ],
                            components: [
                                (function() {
                                    var cmp = createActorBehavior(actorType.PROGRAM, getAvailableWaypoint());

                                    cmp.update = function() {
                                        if (levelCompleted || corruptionLevel >= corruptionRequired) {
                                            cmp.actor.kill();
                                        }

                                        if (cmp.actor.status == actorStatus.DEAD) {
                                            cmp.actor.setWaypoint(null);
                                            cmp.node.getParent().detachNode(cmp.node);
                                            cmp.node.cleanup();
                                            return;
                                        }

                                        if (cmp.actor.status == actorStatus.IDLE) {
                                            var choice = Math.random();
                                            if (choice > 0.75) {
                                                cmp.moveForward();
                                            }
                                            else if (choice > 0.35) {
                                                cmp.turnLeft();
                                            }
                                            else {
                                                cmp.turnRight();
                                            }
                                        }

                                        cmp.node.perform(crimild.core.worldStateUpdate());
                                    };

                                    return cmp;
                                })(),
                                (function() {
                                    var time = 0;

                                    var cmp = crimild.rendering.shaderUniformComponent({
                                        uniforms: [
                                            crimild.rendering.shaderUniform({
                                                name: "uTime",
                                                data: time,
                                                type: crimild.rendering.shaderUniform.type.FLOAT,
                                            }),
                                            crimild.rendering.shaderUniform({
                                                name: "uAppTime",
                                                data: time,
                                                type: crimild.rendering.shaderUniform.type.FLOAT,
                                            }),
                                        ]
                                    });

                                    cmp.update = function(appTime, deltaTime) {
                                        cmp.getUniform("uAppTime").data = appTime / 1000.0;

                                        if (cmp.node.getComponent("behavior").actor.status == actorStatus.DYING) {
                                            if (time <= 1.0) {
                                                cmp.getUniform("uTime").data = time;
                                                time += deltaTime / 1000.0;
                                            }
                                            else {
                                                cmp.node.getComponent("behavior").actor.status = actorStatus.DEAD;
                                            }
                                        }
                                    };

                                    return cmp;
                                })(),
                            ],
                        });
                    };

                    var createAntivirus = function() {
                        return crimild.core.geometryNode({
                            primitives: [
                                crimild.primitives.diamondPrimitive({
                                    scale: [0.35, 0.45, 0.35],
                                    textureOffset: [0.0, 0.25],
                                    textureScale: [0.25, 0.25],
                                }),
                                crimild.core.primitive({
                                    type: crimild.core.primitive.types.TRIANGLES,
                                    vertexBuffer: crimild.core.vertexBufferObject({
                                        vertexFormat: crimild.core.vertexFormat({
                                            positions: 3,
                                            textureCoords: 2,
                                        }),
                                        data: new Float32Array([
                                            -0.15, -0.49, -0.15, 0.51, 0.26, 
                                            -0.15, -0.49, 0.15, 0.51, 0.49, 
                                            0.15, -0.49, 0.15, 0.74, 0.49, 
                                            0.15, -0.49, -0.15, 0.74, 0.26, 
                                        ]),
                                        vertexCount: 4,
                                    }),
                                    indexBuffer: crimild.core.indexBufferObject({
                                        data: new Uint16Array([0, 1, 2, 0, 2, 3]),
                                        indexCount: 6
                                    })
                                }),
                            ],
                            components: [
                                crimild.rendering.renderComponent({
                                    effects: [
                                        crimild.rendering.effect({
                                            textures: [
                                                megaTexture,
                                            ],
                                            alphaState: crimild.rendering.alphaState({ enabled: true }),
                                        }),
                                    ],
                                }),
                                (function() {
                                    var cmp = createActorBehavior(actorType.ANTIVIRUS, getAvailableWaypoint());

                                    var audioElement = loadAudio("assets/agent.wav", true, true);

                                    cmp.update = function() {
                                        audioElement.volume = 0;

                                        if (levelCompleted) {
                                            cmp.actor.status = actorStatus.DEAD;
                                        }

                                        if (cmp.actor.status == actorStatus.DEAD) {
                                            cmp.actor.setWaypoint(null);
                                            cmp.node.getParent().detachNode(cmp.node);
                                            cmp.node.cleanup();
                                            return;
                                        }

                                        if (playerActor.status == actorStatus.DEAD || playerActor.status == actorStatus.DYING) {
                                            return;
                                        }

                                        if (cmp.actor.status == actorStatus.IDLE) {
                                            if (!cmp.moveForward()) {
                                                var choice = Math.random();
                                                if (choice > 0.5) {
                                                    cmp.turnLeft();
                                                }
                                                else {
                                                    cmp.turnRight();
                                                }
                                            }
                                        }

                                        var front = cmp.getWaypointAtFront();
                                        if (front && front.actor && front.actor.type == actorType.PLAYER) {
                                            front.actor.kill(cmp.actor);
                                        }

                                        if (playerActor) {
                                            var d = vec2.dist(playerActor.position, cmp.actor.position);
                                            console.log(1.0 - d / settings.MAP_SIZE_DIAGONAL);
                                            audioElement.volume = Math.min(1.0, 1.0 - d / settings.MAP_SIZE_DIAGONAL);
                                        }

                                        if (playerActor && riskLevel != playerRiskLevel.FOUND) {
                                            var playerFound = false;

                                            if (playerActor.position[0] == cmp.actor.position[0]) {
                                                if (playerActor.position[1] < cmp.actor.position[1]) {
                                                    var tempWp = cmp.actor.waypoint.northNeighbor;
                                                    while (tempWp && !playerFound) {
                                                        if (tempWp.actor && tempWp.actor.type == actorType.PLAYER) {
                                                            playerFound = true;
                                                        }

                                                        tempWp = tempWp.northNeighbor;
                                                    }
                                                }
                                                else if (playerActor.position[1] > cmp.actor.position[1]) {
                                                    var tmpWp = cmp.actor.waypoint.southNeighbor;
                                                    while (tmpWp && !playerFound) {
                                                        if (tmpWp.actor && tmpWp.actor.type == actorType.PLAYER) {
                                                            playerFound = true;
                                                        }
                                                        tmpWp = tmpWp.southNeighbor;
                                                    }
                                                }
                                            }
                                            else if (playerActor.position[1] == cmp.actor.position[1]) {
                                                if (playerActor.position[0] < cmp.actor.position[0]) {
                                                    var tmpWp = cmp.actor.waypoint.westNeighbor;
                                                    while (tmpWp && !playerFound) {
                                                        if (tmpWp.actor && tmpWp.actor.type == actorType.PLAYER) {
                                                            playerFound = true;
                                                        }
                                                        tmpWp = tmpWp.westNeighbor;
                                                    }
                                                }
                                                else if (playerActor.position[0] > cmp.actor.position[0]) {
                                                    var tmpWp = cmp.actor.waypoint.eastNeighbor;
                                                    while (tmpWp && !playerFound) {
                                                        if (tmpWp.actor && tmpWp.actor.type == actorType.PLAYER) {
                                                            playerFound = true;
                                                        }
                                                        tmpWp = tmpWp.eastNeighbor;
                                                    }
                                                }
                                            }
                                            
                                            if (playerFound) {
                                                riskLevel = playerRiskLevel.FOUND;
                                            }
                                        }

                                        cmp.node.perform(crimild.core.worldStateUpdate());
                                    };

                                    return cmp;
                                })(),
                            ],
                        });
                    };

                    var createKernel = function() {
                        return crimild.core.groupNode({
                            nodes: [
                                crimild.core.geometryNode({
                                    primitives: [
                                        crimild.primitives.cubePrimitive({
                                            scale: [0.25, 0.25, 0.25],
                                            textureOffset: [0.0, 0.75],
                                            textureScale: [0.25, 0.25],
                                        }),
                                        crimild.core.primitive({
                                            type: crimild.core.primitive.types.TRIANGLES,
                                            vertexBuffer: crimild.core.vertexBufferObject({
                                                vertexFormat: crimild.core.vertexFormat({
                                                    positions: 3,
                                                    textureCoords: 2,
                                                }),
                                                data: new Float32Array([
                                                    -0.15, -0.49, -0.15, 0.51, 0.26, 
                                                    -0.15, -0.49, 0.15, 0.51, 0.49, 
                                                    0.15, -0.49, 0.15, 0.74, 0.49, 
                                                    0.15, -0.49, -0.15, 0.74, 0.26, 
                                                ]),
                                                vertexCount: 4,
                                            }),
                                            indexBuffer: crimild.core.indexBufferObject({
                                                data: new Uint16Array([0, 1, 2, 0, 2, 3]),
                                                indexCount: 6
                                            })
                                        }),
                                    ],
                                    components: [
                                        crimild.rendering.renderComponent({
                                            effects: [
                                                crimild.rendering.effect({
                                                    shaderProgram: crimild.rendering.shaderProgram({
                                                        vertexShader: crimild.rendering.shader({
                                                            scriptId: "dissolve-vs"
                                                        }),
                                                        fragmentShader: crimild.rendering.shader({
                                                            scriptId: "dissolve-fs"
                                                        })
                                                    }),
                                                    textures: [
                                                        megaTexture,
                                                    ],
                                                    alphaState: crimild.rendering.alphaState({ enabled: true }),
                                                }),
                                            ],
                                        }),
                                    ],
                                }),
                            ],
                            components: [
                                (function() {
                                    var cmp = createActorBehavior(actorType.PROGRAM, getAvailableWaypoint());

                                    cmp.update = function() {
                                        if (cmp.actor.status == actorStatus.DEAD) {
                                            cmp.actor.setWaypoint(null);
                                            cmp.node.getParent().detachNode(cmp.node);
                                            cmp.node.cleanup();

                                            levelCompleted = true;
                                            showLevelCompleted();
                                            return;
                                        }

                                        if (cmp.actor.status == actorStatus.IDLE) {
                                            var choice = Math.random();
                                            if (choice > 0.75) {
                                                cmp.moveForward();
                                            }
                                            else if (choice > 0.35) {
                                                cmp.turnLeft();
                                            }
                                            else {
                                                cmp.turnRight();
                                            }
                                        }

                                        cmp.node.perform(crimild.core.worldStateUpdate());
                                    };

                                    return cmp;
                                })(),
                                (function() {
                                    var time = 0;

                                    var cmp = crimild.rendering.shaderUniformComponent({
                                        uniforms: [
                                            crimild.rendering.shaderUniform({
                                                name: "uTime",
                                                data: time,
                                                type: crimild.rendering.shaderUniform.type.FLOAT,
                                            }),
                                        ]
                                    });

                                    cmp.update = function(appTime, deltaTime) {
                                        if (cmp.node.getComponent("behavior").actor.status == actorStatus.DYING) {
                                            if (time < 1.0) {
                                                time += deltaTime / 1000.0;
                                                cmp.getUniform("uTime").data = time;
                                            }
                                            else {
                                                cmp.node.getComponent("behavior").actor.status = actorStatus.DEAD;
                                            }
                                        }
                                    };

                                    return cmp;
                                })(),
                            ],
                        });
                    };

                    var scene = crimild.core.groupNode({
                        name: "scene",
                        nodes: [
                            (function() {
                                var walls = {
                                    vertices: [],
                                    indices: [],
                                    indexCount: 0,
                                    vertexCount: 0,
                                    height: 1.0,
                                };

                                var floor = {
                                    vertices: [],
                                    indices: [],
                                    indexCount: 0,
                                    vertexCount: 0,
                                }

                                for (var z = 0; z < mapSizeY; z++) {
                                    for (var x = 0; x < mapSizeX; x++) {
                                        var tile = worldMap[z * mapSizeX + x];
                                        if (tile === tiles.WALL) {
                                            // v0
                                            walls.vertices.push(x - 0.5); 
                                            walls.vertices.push(0); 
                                            walls.vertices.push(z - 0.5); 
                                            walls.vertices.push(0.51);
                                            walls.vertices.push(0.24);

                                            // v1
                                            walls.vertices.push(x - 0.5); 
                                            walls.vertices.push(0); 
                                            walls.vertices.push(z + 0.5);
                                            walls.vertices.push(0.74);
                                            walls.vertices.push(0.24);

                                            // v2
                                            walls.vertices.push(x + 0.5); 
                                            walls.vertices.push(0); 
                                            walls.vertices.push(z + 0.5);
                                            walls.vertices.push(0.51);
                                            walls.vertices.push(0.24);

                                            // v3
                                            walls.vertices.push(x + 0.5); 
                                            walls.vertices.push(0); 
                                            walls.vertices.push(z - 0.5);
                                            walls.vertices.push(0.74);
                                            walls.vertices.push(0.24);

                                            // v4
                                            walls.vertices.push(x - 0.5); 
                                            walls.vertices.push(walls.height); 
                                            walls.vertices.push(z - 0.5); 
                                            walls.vertices.push(0.51);
                                            walls.vertices.push(0.1);

                                            // v5
                                            walls.vertices.push(x - 0.5); 
                                            walls.vertices.push(walls.height); 
                                            walls.vertices.push(z + 0.5);
                                            walls.vertices.push(0.74);
                                            walls.vertices.push(0.1);

                                            // v6
                                            walls.vertices.push(x + 0.5); 
                                            walls.vertices.push(walls.height); 
                                            walls.vertices.push(z + 0.5);
                                            walls.vertices.push(0.51);
                                            walls.vertices.push(0.1);

                                            // v7
                                            walls.vertices.push(x + 0.5); 
                                            walls.vertices.push(walls.height); 
                                            walls.vertices.push(z - 0.5);
                                            walls.vertices.push(0.74);
                                            walls.vertices.push(0.1);

                                            // north wall
                                            walls.indices.push(walls.vertexCount + 7);
                                            walls.indices.push(walls.vertexCount + 3);
                                            walls.indices.push(walls.vertexCount + 0);
                                            walls.indices.push(walls.vertexCount + 7);
                                            walls.indices.push(walls.vertexCount + 0);
                                            walls.indices.push(walls.vertexCount + 4);
                                            
                                            // south wall
                                            walls.indices.push(walls.vertexCount + 5);
                                            walls.indices.push(walls.vertexCount + 1);
                                            walls.indices.push(walls.vertexCount + 2);
                                            walls.indices.push(walls.vertexCount + 5);
                                            walls.indices.push(walls.vertexCount + 2);
                                            walls.indices.push(walls.vertexCount + 6);
                                            
                                            // east wall
                                            walls.indices.push(walls.vertexCount + 6);
                                            walls.indices.push(walls.vertexCount + 2);
                                            walls.indices.push(walls.vertexCount + 3);
                                            walls.indices.push(walls.vertexCount + 6);
                                            walls.indices.push(walls.vertexCount + 3);
                                            walls.indices.push(walls.vertexCount + 7);
                                            
                                            // west wall
                                            walls.indices.push(walls.vertexCount + 4);
                                            walls.indices.push(walls.vertexCount + 0);
                                            walls.indices.push(walls.vertexCount + 1);
                                            walls.indices.push(walls.vertexCount + 4);
                                            walls.indices.push(walls.vertexCount + 1);
                                            walls.indices.push(walls.vertexCount + 5);
                                            
                                            walls.vertexCount += 8;
                                        }
                                        else if (tile === tiles.FLOOR) {
                                            // v0
                                            floor.vertices.push(x - 0.5); 
                                            floor.vertices.push(0); 
                                            floor.vertices.push(z - 0.5); 
                                            floor.vertices.push(0.01);
                                            floor.vertices.push(0.01);

                                            // v1
                                            floor.vertices.push(x - 0.5); 
                                            floor.vertices.push(0); 
                                            floor.vertices.push(z + 0.5);
                                            floor.vertices.push(0.01);
                                            floor.vertices.push(0.24);

                                            // v2
                                            floor.vertices.push(x + 0.5); 
                                            floor.vertices.push(0); 
                                            floor.vertices.push(z + 0.5);
                                            floor.vertices.push(0.24);
                                            floor.vertices.push(0.24);

                                            // v3
                                            floor.vertices.push(x + 0.5); 
                                            floor.vertices.push(0); 
                                            floor.vertices.push(z - 0.5);
                                            floor.vertices.push(0.24);
                                            floor.vertices.push(0.01);

                                            floor.indices.push(floor.vertexCount + 0);
                                            floor.indices.push(floor.vertexCount + 1);
                                            floor.indices.push(floor.vertexCount + 2);
                                            floor.indices.push(floor.vertexCount + 0);
                                            floor.indices.push(floor.vertexCount + 2);
                                            floor.indices.push(floor.vertexCount + 3);
                                            floor.vertexCount += 4;
                                        }
                                    }
                                }

                                return crimild.core.groupNode({
                                    name: "world",
                                    nodes: [
                                        crimild.core.geometryNode({
                                            name: "floor",
                                            primitives: [
                                                crimild.core.primitive({
                                                    type: crimild.core.primitive.types.TRIANGLES,
                                                    vertexBuffer: crimild.core.vertexBufferObject({
                                                        vertexFormat: crimild.core.vertexFormat({positions: 3, textureCoords: 2}),
                                                        data: new Float32Array(floor.vertices),
                                                        vertexCount: floor.vertices.length / 5,
                                                    }),
                                                    indexBuffer: crimild.core.indexBufferObject({
                                                        data: new Uint16Array(floor.indices),
                                                        indexCount: floor.indices.length,
                                                    })
                                                })
                                            ],
                                            components: [
                                                (function() {
                                                    var diffuse = vec3.create();
                                                    var time = 0.0;

                                                    var that = crimild.rendering.renderComponent({
                                                        effects: [
                                                            crimild.rendering.effect({
                                                                textures: [
                                                                    megaTexture
                                                                ],
                                                            })
                                                        ]
                                                    });
                                                    
                                                    that.update = function(appTime, deltaTime) {
                                                        var from = [1, 0, 0];
                                                        var to = [0, 1, 0];

                                                        if (playerActor.status == actorStatus.DEAD) {
                                                            from = [0.1, 0.1, 0.1];
                                                            to = [0.5, 0.5, 0.5];
                                                        }
                                                        else if (riskLevel == playerRiskLevel.SAFE) {
                                                            from = [0.25, 0.25, 1.0];
                                                            to = [0.5, 0.5, 1.0];
                                                        }
                                                        else if (riskLevel == playerRiskLevel.WARNING) {
                                                            from = [0.5, 0.5, 0.0];
                                                            to = [1.0, 1.0, 0.0];
                                                        }
                                                        else if (riskLevel == playerRiskLevel.FOUND) {
                                                            from = [0.75, 0.0, 0.0];
                                                            to = [1.0, 0.25, 0.25];
                                                        }

                                                        time += (2 * deltaTime) / 1000;
                                                        crimild.math.numeric.computeBezier3D([from, to], -0.5 * Math.cos(time) + 0.5, that.getEffectAt(0).diffuse);
                                                    };

                                                    return that;
                                                })(),
                                            ]
                                        }),
                                        crimild.core.geometryNode({
                                            name: "walls",
                                            primitives: [
                                                crimild.core.primitive({
                                                    type: crimild.core.primitive.types.TRIANGLES,
                                                    vertexBuffer: crimild.core.vertexBufferObject({
                                                        vertexFormat: crimild.core.vertexFormat({positions: 3, textureCoords: 2}),
                                                        data: new Float32Array(walls.vertices),
                                                        vertexCount: walls.vertices.length / 5,
                                                    }),
                                                    indexBuffer: crimild.core.indexBufferObject({
                                                        data: new Uint16Array(walls.indices),
                                                        indexCount: walls.indices.length,
                                                    })
                                                })
                                            ],
                                            components: [
                                                (function() {
                                                    var diffuse = vec3.create();
                                                    var time = 0.0;

                                                    var that = crimild.rendering.renderComponent({
                                                        effects: [
                                                            crimild.rendering.effect({
                                                                shaderProgram: crimild.rendering.shaderProgram({
                                                                    vertexShader: crimild.rendering.shader({
                                                                        scriptId: "dissolve-vs"
                                                                    }),
                                                                    fragmentShader: crimild.rendering.shader({
                                                                        scriptId: "dissolve-fs"
                                                                    })
                                                                }),
                                                                textures: [
                                                                    megaTexture
                                                                ],
                                                            })
                                                        ]
                                                    });
                                                    
                                                    that.update = function(appTime, deltaTime) {
                                                        var from = [1, 0, 0];
                                                        var to = [0, 1, 0];

                                                        if (playerActor.status == actorStatus.DEAD) {
                                                            from = [0.25, 0.25, 0.1];
                                                            to = [0.5, 0.5, 0.5];
                                                        }
                                                        else if (riskLevel == playerRiskLevel.SAFE) {
                                                            from = [0.1, 0.1, 1.0];
                                                            to = [0.5, 0.5, 1.0];
                                                        }
                                                        else if (riskLevel == playerRiskLevel.WARNING) {
                                                            from = [0.5, 0.5, 0.0];
                                                            to = [1.0, 1.0, 0.0];
                                                        }
                                                        else if (riskLevel == playerRiskLevel.FOUND) {
                                                            from = [0.75, 0.0, 0.0];
                                                            to = [1.0, 0.25, 0.25];
                                                        }

                                                        time += (2 * deltaTime) / 1000;
                                                        crimild.math.numeric.computeBezier3D([from, to], -0.5 * Math.cos(time) + 0.5, that.getEffectAt(0).diffuse);
                                                    };

                                                    return that;
                                                })(),
                                                (function() {
                                                    var time = 0;
                                                    var max = 0;

                                                    var cmp = crimild.rendering.shaderUniformComponent({
                                                        uniforms: [
                                                            crimild.rendering.shaderUniform({
                                                                name: "uTime",
                                                                data: time,
                                                                type: crimild.rendering.shaderUniform.type.FLOAT,
                                                            }),
                                                        ]
                                                    });

                                                    cmp.update = function(appTime, deltaTime) {
                                                        if (time < Math.min(1.0, corruptionLevel / corruptionRequired)) {
                                                            time += 0.25 * deltaTime / 1000.0;
                                                        }

                                                        cmp.getUniform("uTime").data = time;
                                                    };

                                                    return cmp;
                                                })(),
                                            ]
                                        }),
                                    ],
                                    components: [
                                    ],
                                    local: crimild.math.transformation({
                                        translate: [0, -0.5, 0],
                                    })
                                });
                            })(),
                            crimild.core.groupNode({
                                name: "player",
                                nodes: [
                                    crimild.rendering.cameraNode({
                                        aspectRatio: canvas.width / canvas.height,
                                    }),
                                ],
                                components: [
                                    (function() {
                                        var cmp = createActorBehavior(actorType.PLAYER, getRandomWaypoint(waypoints));

                                        var derezzAudio = loadAudio("assets/derezz.wav", false);

                                        var superOnAttach = cmp.onAttach;
                                        cmp.onAttach = function() {
                                            superOnAttach();

                                            if (!cmp.actor.waypoint.northNeighbor) {
                                                var factor = 0;
                                                if (cmp.actor.waypoint.southNeighbor) {
                                                    factor = 2;
                                                    cmp.actor.orientation = actorOrientation.SOUTH;
                                                }
                                                else if (cmp.actor.waypoint.westNeighbor) {
                                                    factor = 1;
                                                    cmp.actor.orientation = actorOrientation.WEST;
                                                }
                                                else if (cmp.actor.waypoint.eastNeighbor) {
                                                    factor = -1;
                                                    cmp.actor.orientation = actorOrientation.EAST;
                                                }

                                                cmp.node.local.rotate = quat4.fromAngleAxis(factor * Math.PI / 2, [0, 1, 0]);
                                                cmp.node.perform(crimild.core.worldStateUpdate());
                                            }
                                        };

                                        cmp.update = function() {
                                            if (cmp.actor.status == actorStatus.DEAD) {
                                                showGameOver();
                                                return;
                                            }
                                            else if (cmp.actor.status == actorStatus.DYING) {
                                                if (cmp.actor.killer) {
                                                    var endTransformation = crimild.math.transformation();
                                                    endTransformation.set(cmp.node.local);

                                                    var coeff = 0;

                                                    var killerPosition = cmp.actor.killer.position;
                                                    var actorPosition = cmp.actor.position;

                                                    if (actorPosition[0] == killerPosition[0]) {
                                                        if (actorPosition[1] > killerPosition[1]) {
                                                            // target is at north
                                                            if (cmp.actor.orientation == actorOrientation.NORTH) {
                                                                coeff = 0;
                                                            }
                                                            else if (cmp.actor.orientation == actorOrientation.SOUTH) {
                                                                coeff = 2;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.WEST) {
                                                                coeff = -1;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.EAST) {
                                                                coeff = 1;
                                                            }
                                                        }
                                                        else {
                                                            // target is at south
                                                            if (cmp.actor.orientation == actorOrientation.NORTH) {
                                                                coeff = 2;
                                                            }
                                                            else if (cmp.actor.orientation == actorOrientation.SOUTH) {
                                                                coeff = 0;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.WEST) {
                                                                coeff = 1;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.EAST) {
                                                                coeff = -1;
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        if (actorPosition[0] > killerPosition[0]) {
                                                            // target is at west
                                                            if (cmp.actor.orientation == actorOrientation.NORTH) {
                                                                coeff = 1;
                                                            }
                                                            else if (cmp.actor.orientation == actorOrientation.SOUTH) {
                                                                coeff = -1;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.EAST) {
                                                                coeff = 2;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.WEST) {
                                                                coeff = 0;
                                                            }
                                                        }
                                                        else {
                                                            // target is at east
                                                            if (cmp.actor.orientation == actorOrientation.NORTH) {
                                                                coeff = -1;
                                                            }
                                                            else if (cmp.actor.orientation == actorOrientation.SOUTH) {
                                                                coeff = 1;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.WEST) {
                                                                coeff = 2;
                                                            }
                                                            else if(cmp.actor.orientation == actorOrientation.EAST) {
                                                                coeff = 0;
                                                            }
                                                        }
                                                    }

                                                    if (coeff != 0) {
                                                        var qTemp = quat4.create();
                                                        quat4.fromAngleAxis(coeff * Math.PI / 2, [0, 1, 0], qTemp);
                                                        quat4.multiply(cmp.node.local.rotate, qTemp, endTransformation.rotate);

                                                        cmp.node.attachComponent(crimild.components.lerpTransformComponent({
                                                            name: "interpolateBehavior",
                                                            start: cmp.node.local,
                                                            end: endTransformation,
                                                            speed: cmp.actor.speed,
                                                            callback: function() {
                                                            }
                                                        }));
                                                    }
                                                }
                                                cmp.actor.status = actorStatus.DEAD;
                                            }
                                            else if (cmp.actor.status == actorStatus.IDLE) {
                                                if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_WALK_FORWARD) || crimild.simulation.simulator.input.isKeyDown(settings.KEY_WALK_FORWARD_ALT)) {
                                                    cmp.moveForward();
                                                }
                                                else if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_WALK_BACKWARD) || crimild.simulation.simulator.input.isKeyDown(settings.KEY_WALK_BACKWARD_ALT)) {
                                                    cmp.moveBackward();
                                                }
                                                else if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_STRAFE_LEFT)) {
                                                    cmp.moveLeft();
                                                }
                                                else if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_STRAFE_RIGHT)) {
                                                    cmp.moveRight();
                                                }
                                                else if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_TURN_LEFT) || crimild.simulation.simulator.input.isKeyDown(settings.KEY_TURN_LEFT_ALT)) {
                                                    cmp.turnLeft();
                                                }
                                                else if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_TURN_RIGHT) || crimild.simulation.simulator.input.isKeyDown(settings.KEY_TURN_RIGHT_ALT)) {
                                                    cmp.turnRight();
                                                }
                                                
                                                if (crimild.simulation.simulator.input.isKeyDown(settings.KEY_ATTACK)) {
                                                    var wp = cmp.getWaypointAtFront();
                                                    if (wp && wp.actor) {
                                                        if (wp.actor.type == actorType.PROGRAM) {
                                                            derezzAudio.play();
                                                            wp.actor.kill();
                                                        }
                                                    }
                                                }
                                            }

                                            cmp.node.perform(crimild.core.worldStateUpdate());

                                            $('#debug #position').html(vec2.str(cmp.actor.position));
                                            $('#debug #orientation').html(cmp.actor.orientation);
                                            $('#debug #status').html(cmp.actor.status);
                                            $('#debug #corruption').html(Math.floor(corruptionLevel * 100));
                                            $('#debug #corruptionRequired').html(Math.floor(corruptionRequired * 100));
                                        };

                                        return cmp;
                                    })(),
                                ],
                            }),
                            crimild.core.groupNode({
                                name: "programs",
                                components: [
                                    (function() {
                                        var cmp = crimild.core.nodeComponent();

                                        cmp.onAttach = function() {
                                            for (var i = 0; i < settings.PROGRAM_COUNT; i++) {
                                                cmp.node.attachNode(createProgram());
                                            }
                                        };

                                        cmp.update = function() {
                                            corruptionLevel = 1.0 - cmp.node.getNodeCount() / settings.PROGRAM_COUNT;
                                        };

                                        return cmp;
                                    })(),
                                ],
                            }),
                            crimild.core.groupNode({
                                name: "kernel",
                                components: [
                                    (function() {
                                        var cmp = crimild.core.nodeComponent();

                                        cmp.update = function() {
                                            if (!levelCompleted && corruptionLevel >= corruptionRequired && cmp.node.getNodeCount() == 0) {
                                                cmp.node.attachNode(createKernel());                                                
                                                cmp.node.perform(crimild.core.worldStateUpdate());
                                                cmp.node.perform(crimild.rendering.renderStateUpdate());
                                                riskLevel = playerRiskLevel.FOUND;
                                            }
                                        };

                                        return cmp;
                                    })(),
                                ],
                            }),
                            crimild.core.groupNode({
                                name: "defenses",
                                components: [
                                    (function() {
                                        var cmp = crimild.core.nodeComponent();

                                        cmp.update = function() {
                                            if (levelCompleted) {
                                                riskLevel = playerRiskLevel.SAFE;
                                                return;
                                            }

                                            if (corruptionLevel >= corruptionRequired) {
                                                riskLevel = playerRiskLevel.FOUND;
                                            }
                                            else {
                                                if (Math.floor(settings.ANTIVIRUS_COUNT * corruptionLevel) > cmp.node.getNodeCount()) {
                                                    cmp.node.attachNode(createAntivirus());
                                                    cmp.node.perform(crimild.core.worldStateUpdate());
                                                    cmp.node.perform(crimild.rendering.renderStateUpdate());
                                                }

                                                if (cmp.node.getNodeCount() > 0) {
                                                    riskLevel = playerRiskLevel.WARNING;                                                
                                                }
                                                else {
                                                    riskLevel = playerRiskLevel.SAFE;                                        
                                                }
                                            }
                                        };

                                        return cmp;
                                    })(),
                                ],
                            }),
                        ]
                    });

                    crimild.simulation.run({
                        canvas: canvas, 
                        scenes: [scene],
                        grabInput: true,
                    }).getRenderer().setClearColor(0, 0, 0, 1);
                }
            });
        }
    </script>
</head>

<body onload="initCrimild('webGLCanvas');" style="background-color: black;">
    <div id="loading">
        <div class="hud">
            <p>loading, please wait...</p>
        </div>
    </div>

    <div id="mainMenu" class="menu" style="display: none;">
        <div>
            <h2>Choose difficulty level</h2>
            <p>
                Difficulty affects the number of programs you need to corrupt in order to expose
                the Kernel, as well as the number of hostile processes dispatched to protect the system
            </p>
            <p style="padding-top: 10px;">
                <a class="btn btn-inverse btn-large start-game-easy">Easy &raquo;</a>
                <a class="btn btn-inverse btn-large start-game-normal">Normal &raquo;</a>
                <a class="btn btn-inverse btn-large start-game-hard">Hard &raquo;</a>
                <a class="btn btn-inverse btn-large start-game-hardcore">Hardcore &raquo;</a>
            </p>
            <div class="help">
                <h2>Tips:</h2>
                <ul>
                    <li>Use cursor keys (or WASD) to move</li>
                    <li>Hit SPACE to consume a program o corrupt the Kernel</li>
                    <li>If you see an agent... RUN!</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="gameOver" class="menu" style="display: none;">
        <div>
            <h1>Game Over</h1>
            <p>You have been terminated</p>
            <p><a class="btn btn-inverse btn-large btn-game-over" href="game.html">Main Menu &raquo;</a></p>
        </div>
    </div>

    <div id="levelCompleted" class="menu" style="display: none;">
        <div>
            <h1>Mission accomplished!</h1>
            <p>You have corrupted the system.</p>
            <p>
                <a class="btn btn-inverse btn-large btn-next-level">Next &raquo;</a>
                <a class="btn btn-inverse btn-large btn-main-menu" href="game.html">Main Menu &raquo;</a>
            </p>
        </div>
    </div>

    <div id="game" style="display: none;">
        <canvas id="webGLCanvas">
            Your browser does not support WebGL
        </canvas>

        <div class="hud">
            <p>Level: <span id="level"></span></p>
            <div id="debug" style="position: absolute; top: 200px; left: 10px; width: 400px; display: none;">
                <p>Position: <span id="position"></span></p>
                <p>Orientation: <span id="orientation"></span></p>
                <p>Status: <span id="status"></span></p>
                <p>Corruption: <span id="corruption"></span>%</p>
                <p>Required: <span id="corruptionRequired"></span>%</p>
                <p>Light: <span id="light"></span></p>
            </div>
        </div>
    </div>
</body>
</html>

